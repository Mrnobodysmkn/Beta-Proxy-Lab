name: Golden Hybrid - Smart Validator

permissions:
  contents: write

on:
  schedule:
    - cron: '0 */2 * * *'
  workflow_dispatch:

jobs:
  laboratory:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v3

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install Dependencies
      run: |
        pip install requests urllib3

    - name: Run The Alchemist Script
      run: |
        rm -f golden_*.txt
        
        cat << 'EOF' > alchemist.py
        import requests
        import base64
        import json
        import re
        import copy
        import concurrent.futures
        import random
        import urllib3
        from urllib.parse import quote
        
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        
        # Ù‡Ø¯Ø±Ù‡Ø§ÛŒ Ø®ÛŒÙ„ÛŒ ÙˆØ§Ù‚Ø¹ÛŒâ€ŒØªØ± Ø¨Ø±Ø§ÛŒ ÙØ±ÛŒØ¨ Ø¢Ù†ØªÛŒâ€ŒØ¨Ø§Øªâ€ŒÙ‡Ø§
        HEADERS = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/plain,application/json,text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.9',
            'Referer': 'https://www.google.com/',
            'Cache-Control': 'no-cache',
        }

        SOURCES = [
            {'url': 'https://chat.tawana.online/sub/tawanaproxy.txt', 'tag': 'skimia'},
            {'url': 'https://raw.githubusercontent.com/mahdibland/V2RayAggregator/master/EternityAirports_sub.txt', 'tag': 'public'},
            {'url': 'https://raw.githubusercontent.com/ebrasha/free-v2ray-public-list/main/all_extracted_configs.txt', 'tag': 'public'},
        ]

        CF_PORTS = [443, 2053, 2083, 8443, 2096]
        FINAL_CONFIGS = []

        def encode_vmess(data_dict):
            return 'vmess://' + base64.b64encode(json.dumps(data_dict).encode('utf-8')).decode('utf-8')

        # --- ØªØ§Ø¨Ø¹ Ø­ÛŒØ§ØªÛŒ: Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ù…Ø­ØªÙˆØ§ ---
        def is_valid_content(text):
            if not text or len(text) < 10: return False
            # Ø§Ú¯Ø± HTML Ø¨Ø§Ø´Ø¯ ÛŒØ¹Ù†ÛŒ Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª
            if text.strip().startswith('<!DOCTYPE') or text.strip().startswith('<html'):
                return False
            # Ø¨Ø§ÛŒØ¯ Ø­ØªÙ…Ø§ Ù†Ø´Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ø±ÙˆÚ©Ø³ÛŒ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯
            if 'vmess://' in text or 'vless://' in text or 'trojan://' in text or 'ss://' in text:
                return True
            # Ø´Ø§ÛŒØ¯ Ú©Ù„ ÙØ§ÛŒÙ„ Ø¨ÛŒØ³Û¶Û´ Ø¨Ø§Ø´Ø¯ØŒ ØªØ³Øª Ù…ÛŒÚ©Ù†ÛŒÙ…
            try:
                decoded = base64.b64decode(text).decode('utf-8', errors='ignore')
                if 'vmess://' in decoded or 'vless://' in decoded:
                    return True
            except: pass
            return False

        # --- Ø¯Ø§Ù†Ù„ÙˆØ¯ Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø¨Ø§ ØªÙˆÙ†Ù„â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ ---
        def smart_fetch(source):
            url = source['url']
            tag = source['tag']
            print(f"\nğŸ” Targeting: {tag} -> {url}")
            
            # Ù„ÛŒØ³Øª Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ù†Ù„ÙˆØ¯ (Ø§ÙˆÙ„ÙˆÛŒØª Ø¨Ø§ Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ù…Ø³ØªÙ‚ÛŒÙ…â€ŒØªØ±)
            methods = [
                # 1. Ù…Ø³ØªÙ‚ÛŒÙ…
                {'name': 'Direct', 'url': url},
                # 2. Ø³Ø±ÙˆÛŒØ³ AllOrigins (Ø®Ø±ÙˆØ¬ÛŒ Ø®Ø§Ù… JSON) - Ù…Ø¹Ù…ÙˆÙ„Ø§ Ú©Ù…ØªØ± Ø¨Ù„Ø§Ú© Ù…ÛŒØ´Ù‡
                {'name': 'AllOrigins', 'url': f'https://api.allorigins.win/get?url={quote(url)}', 'json_extract': True},
                # 3. Ø³Ø±ÙˆÛŒØ³ Weserv (Ú©Ø´ Ú¯ÙˆÚ¯Ù„)
                {'name': 'Weserv', 'url': f'https://images.weserv.nl/?url={quote(url)}&output=json', 'json_extract': False}, 
                # 4. Ø³Ø±ÙˆÛŒØ³ Https://cors-anywhere.herokuapp.com (Ú¯Ø§Ù‡ÛŒ Ú©Ø§Ø± Ù…ÛŒÚ©Ù†Ù‡)
                # {'name': 'CorsAnywhere', 'url': f'https://cors-anywhere.herokuapp.com/{url}'},
            ]
            
            for method in methods:
                print(f"  ğŸ‘‰ Trying: {method['name']}...")
                try:
                    resp = requests.get(method['url'], headers=HEADERS, timeout=15, verify=False)
                    content = ""
                    
                    if method.get('json_extract'):
                        # Ø¨Ø±Ø§ÛŒ AllOrigins Ú©Ù‡ Ø®Ø±ÙˆØ¬ÛŒ JSON Ù…ÛŒØ¯Ù‡
                        try:
                            json_data = resp.json()
                            content = json_data.get('contents', '')
                        except: content = resp.text
                    else:
                        content = resp.text

                    # **Ù…Ù‡Ù…ØªØ±ÛŒÙ† Ø¨Ø®Ø´: Ú†Ú© Ú©Ø±Ø¯Ù† Ø§Ø¹ØªØ¨Ø§Ø±**
                    if is_valid_content(content):
                        print(f"  âœ… SUCCESS! Valid content received ({len(content)} chars).")
                        return content
                    else:
                        print(f"  âŒ Failed: Content was invalid (HTML or Empty).")
                        
                except Exception as e:
                    print(f"  âŒ Error: {e}")
            
            print(f"  âš ï¸ All fetch methods failed for {tag}")
            return None

        def process_config(line, source_tag):
            configs = []
            original_config = {'uri': line, 'tag': source_tag, 'proto': 'unknown'}
            try:
                line = line.strip()
                if not line: return []
                
                data = None
                protocol = ''
                is_candidate = False
                current_port = 0
                
                if line.startswith('vmess://'):
                    protocol = 'vmess'
                    b64 = line[8:]
                    padding = len(b64) % 4
                    if padding: b64 += '=' * (4 - padding)
                    try:
                        decoded = base64.b64decode(b64).decode('utf-8', errors='ignore')
                        data = json.loads(decoded)
                        if data.get('net') == 'ws':
                            is_candidate = True
                            current_port = int(data.get('port', 0))
                    except:
                        if source_tag == 'skimia': return [original_config]
                        return []
                    if data.get('net') not in ['ws', 'grpc'] and data.get('tls') != 'tls' and source_tag != 'skimia': return []

                elif line.startswith('vless://'):
                    protocol = 'vless'
                    match = re.search(r':(\d+)\?', line) or re.search(r'vless://.*?@.*?:(\d+)', line)
                    if match:
                        current_port = int(match.group(1))
                        if 'security=tls' in line or 'type=ws' in line or 'security=reality' in line:
                            is_candidate = True
                    if not is_candidate and source_tag != 'skimia': return []

                configs.append({'uri': line, 'tag': source_tag, 'proto': protocol})

                if is_candidate and source_tag == 'skimia' and current_port > 0:
                    for port in CF_PORTS:
                        if port == current_port: continue
                        try:
                            if protocol == 'vmess' and data:
                                new_data = copy.deepcopy(data)
                                new_data['port'] = port
                                new_data['ps'] = f"{new_data.get('ps', 'config')}-P{port}"
                                configs.append({'uri': encode_vmess(new_data), 'tag': source_tag, 'proto': 'vmess'})
                            elif protocol == 'vless':
                                new_line = re.sub(r':(\d+)\?', f':{port}?', line, 1)
                                if new_line == line: new_line = re.sub(r':(\d+)$', f':{port}', line, 1)
                                new_line = re.sub(r':(\d+)#', f':{port}#', line, 1)
                                if '#' in new_line:
                                    parts = new_line.split('#')
                                    new_line = f"{parts[0]}#{parts[1]}-P{port}"
                                else: new_line += f"#{port}"
                                configs.append({'uri': new_line, 'tag': source_tag, 'proto': 'vless'})
                        except: continue
            except:
                if source_tag == 'skimia': return [original_config]
                return []
            return configs

        print('Starting Smart Validator...')
        raw_list = []
        
        for src in SOURCES:
            text = smart_fetch(src)
            if not text: continue

            # Ø§Ú¯Ø± Ú©Ù„ Ù…ØªÙ† Ø¨ÛŒØ³Û¶Û´ Ø¨ÙˆØ¯
            if 'vmess://' not in text and 'vless://' not in text:
                try:
                    cleaned = text.replace(' ', '').replace('\n', '')
                    decoded = base64.b64decode(cleaned).decode('utf-8', errors='ignore')
                    if 'vmess://' in decoded or 'vless://' in decoded:
                        text = decoded
                except: pass
            
            # Ø§Ø³ØªØ®Ø±Ø§Ø¬
            found_links = re.findall(r'(vmess://[a-zA-Z0-9+/=]+|vless://[^\s\n]+|trojan://[^\s\n]+|ss://[^\s\n]+)', text)
            if found_links:
                print(f"  -> Extracted {len(found_links)} links.")
                for link in found_links: raw_list.append((link, src['tag']))
            else:
                lines = text.splitlines()
                valid = [l.strip() for l in lines if l.strip() and '://' in l]
                print(f"  -> Found {len(valid)} lines manually.")
                for line in valid: raw_list.append((line, src['tag']))

        with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
            results = executor.map(lambda p: process_config(p[0], p[1]), raw_list)
            for res in results: FINAL_CONFIGS.extend(res)

        print(f'Total Generated: {len(FINAL_CONFIGS)}')

        skimia_lines = [c['uri'] for c in FINAL_CONFIGS if c['tag'] == 'skimia']
        if not skimia_lines:
             with open('golden_skimia.txt', 'w') as f:
                 f.write(f"# Critical: All tunnels failed or blocked. Check Action Logs.")
        else:
            with open('golden_skimia.txt', 'w', encoding='utf-8') as f:
                f.write('\n'.join(skimia_lines))
            
        public_lines = [c['uri'] for c in FINAL_CONFIGS if c['tag'] == 'public']
        random.shuffle(public_lines)
        with open('golden_public_secure.txt', 'w', encoding='utf-8') as f:
            f.write('\n'.join(public_lines[:150]))

        EOF
        
        python3 alchemist.py

    - name: Commit and Push
      run: |
        git config --global user.name "Lab Rat"
        git config --global user.email "lab@github.com"
        git add golden_*.txt
        git commit -m "Smart Validator Mode" || echo "No changes"
        git push
