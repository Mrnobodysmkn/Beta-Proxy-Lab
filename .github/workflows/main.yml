name: Golden Hybrid - Tunnel Mode

permissions:
  contents: write

on:
  schedule:
    - cron: '0 */2 * * *'
  workflow_dispatch:

jobs:
  laboratory:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v3

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install Dependencies
      run: |
        pip install requests urllib3

    - name: Run The Alchemist Script
      run: |
        rm -f golden_*.txt
        
        cat << 'EOF' > alchemist.py
        import requests
        import base64
        import json
        import re
        import copy
        import concurrent.futures
        import random
        import urllib3
        from urllib.parse import quote
        
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        
        HEADERS = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        }

        SOURCES = [
            {'url': 'https://chat.tawana.online/sub/tawanaproxy.txt', 'tag': 'skimia'},
            {'url': 'https://raw.githubusercontent.com/mahdibland/V2RayAggregator/master/EternityAirports_sub.txt', 'tag': 'public'},
            {'url': 'https://raw.githubusercontent.com/ebrasha/free-v2ray-public-list/main/all_extracted_configs.txt', 'tag': 'public'},
        ]

        CF_PORTS = [443, 2053, 2083, 8443, 2096]
        FINAL_CONFIGS = []

        def encode_vmess(data_dict):
            return 'vmess://' + base64.b64encode(json.dumps(data_dict).encode('utf-8')).decode('utf-8')

        # --- تابع جدید: دانلود هوشمند با واسطه ---
        def smart_fetch(source):
            url = source['url']
            tag = source['tag']
            print(f"\nTargeting: {tag} -> {url}")
            
            # لیست روش‌های دانلود (مستقیم + واسطه‌ها)
            fetch_methods = [
                {'name': 'Direct', 'url': url},
                {'name': 'CorsProxy', 'url': f'https://corsproxy.io/?{quote(url)}'},
                {'name': 'AllOrigins', 'url': f'https://api.allorigins.win/raw?url={quote(url)}'},
                {'name': 'ThingProxy', 'url': f'https://thingproxy.freeboard.io/fetch/{url}'}
            ]
            
            for method in fetch_methods:
                print(f"  Trying method: {method['name']}...")
                try:
                    resp = requests.get(method['url'], headers=HEADERS, timeout=15, verify=False)
                    if resp.status_code == 200 and len(resp.text) > 10:
                        print(f"  ✅ Success via {method['name']}! (Size: {len(resp.text)})")
                        return resp.text.strip()
                    else:
                        print(f"  ❌ Failed (Status: {resp.status_code})")
                except Exception as e:
                    print(f"  ❌ Error: {e}")
            
            print(f"  ⚠️ All methods failed for {tag}")
            return None

        def process_config(line, source_tag):
            configs = []
            original_config = {'uri': line, 'tag': source_tag, 'proto': 'unknown'}
            
            try:
                line = line.strip()
                if not line: return []
                
                data = None
                protocol = ''
                is_candidate = False
                current_port = 0
                
                if line.startswith('vmess://'):
                    protocol = 'vmess'
                    b64 = line[8:]
                    padding = len(b64) % 4
                    if padding: b64 += '=' * (4 - padding)
                    try:
                        decoded = base64.b64decode(b64).decode('utf-8', errors='ignore')
                        data = json.loads(decoded)
                        if data.get('net') == 'ws':
                            is_candidate = True
                            current_port = int(data.get('port', 0))
                    except:
                        if source_tag == 'skimia': return [original_config]
                        return []
                    
                    if data.get('net') not in ['ws', 'grpc'] and data.get('tls') != 'tls' and source_tag != 'skimia':
                        return []

                elif line.startswith('vless://'):
                    protocol = 'vless'
                    match = re.search(r':(\d+)\?', line) or re.search(r'vless://.*?@.*?:(\d+)', line)
                    if match:
                        current_port = int(match.group(1))
                        if 'security=tls' in line or 'type=ws' in line or 'security=reality' in line:
                            is_candidate = True
                    
                    if not is_candidate and source_tag != 'skimia': return []

                configs.append({'uri': line, 'tag': source_tag, 'proto': protocol})

                if is_candidate and source_tag == 'skimia' and current_port > 0:
                    for port in CF_PORTS:
                        if port == current_port: continue
                        try:
                            if protocol == 'vmess' and data:
                                new_data = copy.deepcopy(data)
                                new_data['port'] = port
                                new_data['ps'] = f"{new_data.get('ps', 'config')}-P{port}"
                                configs.append({'uri': encode_vmess(new_data), 'tag': source_tag, 'proto': 'vmess'})
                            elif protocol == 'vless':
                                new_line = re.sub(r':(\d+)\?', f':{port}?', line, 1)
                                if new_line == line: new_line = re.sub(r':(\d+)$', f':{port}', line, 1)
                                new_line = re.sub(r':(\d+)#', f':{port}#', line, 1)
                                if '#' in new_line:
                                    parts = new_line.split('#')
                                    new_line = f"{parts[0]}#{parts[1]}-P{port}"
                                else: new_line += f"#{port}"
                                configs.append({'uri': new_line, 'tag': source_tag, 'proto': 'vless'})
                        except: continue

            except:
                if source_tag == 'skimia': return [original_config]
                return []
            return configs

        print('Starting Operation...')
        raw_list = []
        
        for src in SOURCES:
            text = smart_fetch(src)
            if not text: continue

            # تلاش برای دیکد (Base64)
            if 'vmess://' not in text and 'vless://' not in text:
                try:
                    cleaned = text.replace(' ', '').replace('\n', '')
                    decoded = base64.b64decode(cleaned).decode('utf-8', errors='ignore')
                    text = decoded
                except: pass
            
            # استخراج با Regex (ضد گلوله)
            found_links = re.findall(r'(vmess://[a-zA-Z0-9+/=]+|vless://[^\s\n]+|trojan://[^\s\n]+|ss://[^\s\n]+)', text)
            
            if found_links:
                print(f"  -> Extracted {len(found_links)} valid links.")
                for link in found_links:
                    raw_list.append((link, src['tag']))
            else:
                lines = text.splitlines()
                valid = [l.strip() for l in lines if l.strip() and '://' in l]
                print(f"  -> Found {len(valid)} lines manually.")
                for line in valid:
                    raw_list.append((line, src['tag']))

        with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
            results = executor.map(lambda p: process_config(p[0], p[1]), raw_list)
            for res in results:
                FINAL_CONFIGS.extend(res)

        print(f'Total Generated: {len(FINAL_CONFIGS)}')

        skimia_lines = [c['uri'] for c in FINAL_CONFIGS if c['tag'] == 'skimia']
        print(f"Skimia Final Count: {len(skimia_lines)}")
        
        if not skimia_lines:
             with open('golden_skimia.txt', 'w') as f:
                 f.write(f"# Critical Error: Even Tunneling failed. Check source link validity.")
        else:
            with open('golden_skimia.txt', 'w', encoding='utf-8') as f:
                f.write('\n'.join(skimia_lines))
            
        public_lines = [c['uri'] for c in FINAL_CONFIGS if c['tag'] == 'public']
        random.shuffle(public_lines)
        with open('golden_public_secure.txt', 'w', encoding='utf-8') as f:
            f.write('\n'.join(public_lines[:150]))

        EOF
        
        python3 alchemist.py

    - name: Commit and Push
      run: |
        git config --global user.name "Lab Rat"
        git config --global user.email "lab@github.com"
        git add golden_*.txt
        git commit -m "Tunnel Mode Activated" || echo "No changes"
        git push
