name: Golden Hybrid - Browser Mode

permissions:
  contents: write

on:
  schedule:
    - cron: '0 */2 * * *'
  workflow_dispatch:

jobs:
  laboratory:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v3

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install Dependencies
      run: |
        pip install requests urllib3

    - name: Run The Alchemist Script
      run: |
        rm -f golden_*.txt
        
        cat << 'EOF' > alchemist.py
        import requests
        import base64
        import json
        import re
        import copy
        import concurrent.futures
        import random
        import urllib3
        
        # غیرفعال کردن اخطارهای امنیتی SSL
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        
        # --- هدرهای فریبنده (مثل مرورگر کروم) ---
        HEADERS = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
        }

        SOURCES = [
            {'url': 'https://chat.tawana.online/sub/tawanaproxy.txt', 'tag': 'skimia'},
            {'url': 'https://raw.githubusercontent.com/mahdibland/V2RayAggregator/master/EternityAirports_sub.txt', 'tag': 'public'},
            {'url': 'https://raw.githubusercontent.com/ebrasha/free-v2ray-public-list/main/all_extracted_configs.txt', 'tag': 'public'},
        ]

        CF_PORTS = [443, 2053, 2083, 8443, 2096]
        FINAL_CONFIGS = []

        def encode_vmess(data_dict):
            return 'vmess://' + base64.b64encode(json.dumps(data_dict).encode('utf-8')).decode('utf-8')

        def process_config(line, source_tag):
            configs = []
            original_config = {'uri': line, 'tag': source_tag, 'proto': 'unknown'}
            
            try:
                line = line.strip()
                if not line: return []
                
                data = None
                protocol = ''
                is_candidate = False
                current_port = 0
                
                if line.startswith('vmess://'):
                    protocol = 'vmess'
                    b64 = line[8:]
                    padding = len(b64) % 4
                    if padding: b64 += '=' * (4 - padding)
                    try:
                        decoded = base64.b64decode(b64).decode('utf-8', errors='ignore')
                        data = json.loads(decoded)
                        if data.get('net') == 'ws':
                            is_candidate = True
                            current_port = int(data.get('port', 0))
                    except:
                        if source_tag == 'skimia': return [original_config]
                        return []
                    
                    if data.get('net') not in ['ws', 'grpc'] and data.get('tls') != 'tls' and source_tag != 'skimia':
                        return []

                elif line.startswith('vless://'):
                    protocol = 'vless'
                    match = re.search(r':(\d+)\?', line) or re.search(r'vless://.*?@.*?:(\d+)', line)
                    if match:
                        current_port = int(match.group(1))
                        if 'security=tls' in line or 'type=ws' in line or 'security=reality' in line:
                            is_candidate = True
                    
                    if not is_candidate and source_tag != 'skimia': return []

                # اضافه کردن نسخه اصلی
                configs.append({'uri': line, 'tag': source_tag, 'proto': protocol})

                # پورت هاپینگ برای اسکیمیا
                if is_candidate and source_tag == 'skimia' and current_port > 0:
                    for port in CF_PORTS:
                        if port == current_port: continue
                        try:
                            if protocol == 'vmess' and data:
                                new_data = copy.deepcopy(data)
                                new_data['port'] = port
                                new_data['ps'] = f"{new_data.get('ps', 'config')}-P{port}"
                                configs.append({'uri': encode_vmess(new_data), 'tag': source_tag, 'proto': 'vmess'})
                            elif protocol == 'vless':
                                new_line = re.sub(r':(\d+)\?', f':{port}?', line, 1)
                                if new_line == line: new_line = re.sub(r':(\d+)$', f':{port}', line, 1)
                                new_line = re.sub(r':(\d+)#', f':{port}#', line, 1)
                                if '#' in new_line:
                                    parts = new_line.split('#')
                                    new_line = f"{parts[0]}#{parts[1]}-P{port}"
                                else: new_line += f"#{port}"
                                configs.append({'uri': new_line, 'tag': source_tag, 'proto': 'vless'})
                        except: continue

            except:
                if source_tag == 'skimia': return [original_config]
                return []
            return configs

        print('Fetching & Processing...')
        raw_list = []
        
        for src in SOURCES:
            print(f"--- Fetching {src['tag']} from {src['url']} ---")
            try:
                # استفاده از هدرهای مرورگر و غیرفعال کردن وریفای SSL
                resp = requests.get(src['url'], headers=HEADERS, timeout=20, verify=False)
                
                print(f"Status Code: {resp.status_code}")
                
                if resp.status_code != 200:
                    print(f"FAILED! Server returned error code.")
                    continue
                    
                text = resp.text.strip()
                print(f"Content Length: {len(text)}")
                
                # اگر خالی بود
                if not text:
                    print("WARNING: Received empty body!")
                    continue
                    
                # تلاش برای دیکد (Base64)
                if 'vmess://' not in text and 'vless://' not in text:
                    try:
                        cleaned = text.replace(' ', '').replace('\n', '')
                        decoded = base64.b64decode(cleaned).decode('utf-8', errors='ignore')
                        text = decoded
                        print("Base64 decoding successful.")
                    except:
                        print("Base64 decoding failed, trying regex extraction...")
                
                # استخراج با Regex (روش نهایی برای وقتی که فایل به هم ریخته است)
                # پیدا کردن تمام خطوطی که با vmess/vless شروع میشوند
                found_links = re.findall(r'(vmess://[a-zA-Z0-9+/=]+|vless://[^\s\n]+|trojan://[^\s\n]+|ss://[^\s\n]+)', text)
                
                if found_links:
                    print(f"Extracted {len(found_links)} links via Regex.")
                    for link in found_links:
                        raw_list.append((link, src['tag']))
                else:
                    # اگر Regex هم چیزی پیدا نکرد، خط به خط اضافه کن (شاید فرمت ساده باشد)
                    lines = text.splitlines()
                    valid_lines = [l.strip() for l in lines if l.strip() and '://' in l]
                    print(f"Found {len(valid_lines)} valid lines manually.")
                    for line in valid_lines:
                        raw_list.append((line, src['tag']))

            except Exception as e:
                print(f"EXCEPTION: {e}")

        # پردازش نهایی
        with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
            results = executor.map(lambda p: process_config(p[0], p[1]), raw_list)
            for res in results:
                FINAL_CONFIGS.extend(res)

        print(f'Total Generated: {len(FINAL_CONFIGS)}')

        # ذخیره
        skimia_lines = [c['uri'] for c in FINAL_CONFIGS if c['tag'] == 'skimia']
        print(f"Skimia Final Count: {len(skimia_lines)}")
        
        # اگر باز هم خالی بود، یک خط خطا بنویس تا بفهمیم
        if not skimia_lines and any(s['tag'] == 'skimia' for s in SOURCES):
             with open('golden_skimia.txt', 'w') as f:
                 f.write("# Error: Could not fetch proxies. Check Actions Log for details.")
        else:
            with open('golden_skimia.txt', 'w', encoding='utf-8') as f:
                f.write('\n'.join(skimia_lines))
            
        public_lines = [c['uri'] for c in FINAL_CONFIGS if c['tag'] == 'public']
        random.shuffle(public_lines)
        with open('golden_public_secure.txt', 'w', encoding='utf-8') as f:
            f.write('\n'.join(public_lines[:150]))

        EOF
        
        python3 alchemist.py

    - name: Commit and Push
      run: |
        git config --global user.name "Lab Rat"
        git config --global user.email "lab@github.com"
        git add golden_*.txt
        git commit -m "Browser Mimic Mode Activated" || echo "No changes"
        git push
